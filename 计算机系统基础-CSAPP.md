# z计算机系统基础-CSAPP

会以961考纲为基础，以问答的方式进行理解、记忆。

# 一、处理器体系结构

## 1、组合电路和时序电路是什么，它们有什么区别？

- 组合电路：将逻辑门组合成一张网，所构成的计算块
- 时序电路：逻辑门电路和反馈逻辑回路或器件（寄存器）组成

核心区别是：时序电路的输出不仅取决于当时的输入值，而且还与电路过去的状态有关；任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。



## 2、单周期处理器概念及设计？

单周期处理器：在一个时钟周期内完成单条指令：取指、译码、执行、访存、写回、更新PC

- 1、取指：从内存中读取指令，加载至处理器
- 2、译码：对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相应的操作控制信号
- 3、执行：进行相应的逻辑或算术运算
- 4、访存：内存访问（非必要）
- 5、写回：将指令结果写回至寄存器（非必要）
- 6、更新PC：更新程序计数器（将程序计数器指向接下来要执行的指令的地址）



## 3、流水线处理器的概念及基本原理？

可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。

！！！！一定要点出**并行**！！！！！

- 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段
  可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。

- 流水线是如何提高程序性能的？（或者说是流水线的特点）
  - 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器
  - 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器）

## 4、流水线处理器的局限性？

- 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。
- 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。



## 5、流水线冒险、冒险的种类及对应解决方法？

流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。

冒险的种类及解决方法：

- 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务）
  - 插入气泡（流水线气泡）
  - 设置相互独立的指令存储和数据存储

- 数据冒险：存在数据依赖，数据还未产生
  - 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足）
  - 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑）
  - 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期）
  - 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费）
- 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令
  - 插入气泡
  - 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%）
  - 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建



## 6、影响流水线效率的因素？

局限性和流水线冒险，根据上面的解释这两点



## 7、流水线插入气泡技术

插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。



## 8、流水线若干问题及注意点

- 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。
- 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分）
- 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销
- 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。



## 9、解决流水线的局限性-不一致的划分，超标量技术（选看）

Intel处理器中的超线程技术的本质就是超标量技术。

在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。

处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。



## 10、RISC和CISC（20年考到了但是考纲中没有）





# 二、优化程序性能

## 1、什么是Amdahl定律？

- 概念：对系统的某个部分进行加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

- 主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

若系统执行某应用程序需要的时间为$T_{old}$，假设系统某部分所需执行的时间与该时间的比例为$\alpha$，而该部分性能提升比例为$k$。即该部分初始所需时间为$\alpha T_{old}$，现在所需要的时间为$(\alpha T_{old})/k$，因此总的执行时间应为：

$$T_{new}=(1-\alpha) T_{old}+(\alpha T_{old})/k=T_{old}[(1-\alpha)+\alpha /k]$$

由此可以计算加速比$S=T_{old}/T_{new}$为：

$$S=\frac{1}{(1-\alpha)+\alpha k}$$

如果$k$无穷大时，即将这部分加速到一个点，这个点的时间可以忽略不计。

$$S=\frac{1}{(1-\alpha)}$$

## 2、什么是优化编译器的能力和局限性？

以 GCC 编译器为例，可以使用多个优化级别`-O1/-O2/-O3`等，但编译器的优化也是有限的，它只对确定性的可以优化的代码才会优化，对于不确定性的部分，编译器不会对其优化。安全优化：必须要保证未优化的版本和已优化的版本有一样的行为。

为了帮助理解，举不能被优化的例子：

- 内存别名使用：两个指针指向同一个内存位置。编译器必须假设不同的指针会指向内存中同一个位置。
- 大多数编译器不会去判断一个函数是否有副作用。调用一个函数会修改全局程序状态的一部分。即改变调用它的次数会改变程序的行为。

## 3、如何表示程序性能？

CPE：每元素的周期数(Cycles Per Element, CPE)。每个元素的执行需要多少个时间周期。使用时钟周期来表示度量标准比用时间表示有用的多，因为时钟周期表示的是执行了多少条指令，而不是时钟运行的多快。因为时间会和处理器的频率有关。

CPE的有效值：书里用最小二乘法拟合了两条直线。$y=kn+b$，$k$就是CPE的有效值，越小则效率越高。

## 4、消除循环的低效率

一个具体例子，代码移动：识别要执行多次（例如在循环中）但是计算结果不会改变的计算，可以显示的移动到循环前。

可以结合编译器局限性中的安全优化原则，编译器不会做激进的优化，不会去判断一个函数有没有副作用。因此循环对于上述提到的这种值如果不移出循环每次都会再计算一次。

## 5、减少过程调用

一个具体例子，对于合法操作，每次都和循环边界比较。

个人认为链表中设置头结点就是为了减少过程调用。

## 6、消除不必要的内存引用

一个具体例子，累积变量：可以引入临时变量用来累积计算出来的值，并不会每次循环都访问内存，只有在循环完成之后才存放到寄存器中。这样可以将每次迭代的内存操作从两次读和一次写减少到只需要一次读。由于寄存器别名的使用，两个函数可能会有不同的行为，因此编译器无法完成此类优化。

## 7、循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。可以达到延迟界限，无法突破吞吐量界限

延迟界限：按照严格顺序完成合并运算的函数所需要的最小CPE值。

它能够从两方面改善程序的性能：

- 它减少了不直接有助于程序结果的操作的数量。
- 减少整个计算中关键路径上的操作数量。

## 8、提高并行性

不同于循环展开，循环展开仍然是顺序的，它只是减少了循环迭代的次数，可以达到延迟界限，但是无法突破吞吐量界限。但是提高并行性可以达到吞吐量界限。

吞吐量界限：CPE的最小界限。如：只有一个整数乘法器，它的发射时间为一个时钟周期，则处理器不能每个周期执行一条以上的乘法指令。

- 多个累积变量：如连乘操作中，分割成奇数操作和偶数操作，使用不同的执行器，最后再合并。
- 重新结合变换：对应循环展开中的关键路径部分。

## 9、优化程序性能的方法？

- 1、高级设计：选择合适的算法和数据结构。
- 2、基本编码原则：避免限制优化的因素，使编译器产生高效的代码
  - 1)、消除连续的函数调用（消除低效率循环、减少过程调用）：在可能时，将计算移到循环外。
  - 2)、消除不必要的内存引用：引入临时变量来保存中间结果，只有在最后的值计算出来时，才将结果存放到数组或全局变量中。
- 3、低级优化：结构化代码以利用硬件功能。
  - 1)、展开循环，降低开销
  - 2)、提高指令级并行：通过多个累积变量和重新结合技术
  - 3)、用功能性的风格重写条件操作，使得编译采用数据传送。

## 10、优化程序性能的限制因素？

- 1、寄存器溢出：并行度超过了可用寄存器的数量，就会发生溢出。将某些临时值放到内存中，通常是在运行时堆栈上分配空间。
- 2、分支预测和预测错误的惩罚：分支预测逻辑不能正确预测分支是否要跳转，这时条件分支可能会招致很大的预测错误处罚
  - 不要过分关心可预测分支
  - 书写适合用条件传送实现的代码

## 11、如何确认和消除性能瓶颈？

使用程序剖析，确定程序各个部分所需时间。再根据Amdahl定律进行优化。



# 三、存储器层次结构

存储器的层级结构部分的题目，紧扣书中的那个金字塔图、程序的局部性、缓存的工作方式来答。

## 1、存储器的层级结构

从高层往低层走，存储设备逐渐从小而快变得更大、更慢、更便宜，每层都会缓存来自较低一层的数据对象。被缓存的数据对象一般是处理器近期可能会需要的信息，这样可以有效提高读/写效率。

- 寄存器
- L1高速缓存
- L2高速缓存
- L3高速缓存
- 主存
- 本地二级存储（本地磁盘）
- 远程二级存储（分布式文件系统，WEB服务器）

主要思想：上一层的存储器作为低一层的存储器的高速缓存。利用高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势。



## 2、局部性的概念？

倾向于引用邻近于其他最近引用过的数据项的数据项或数据项本身。分为：

- 时间局部性：被引用过一次的内存位置很可能在不远的将来再被多次引用
- 空间局部性：一个内存位置被引用一次，在不远的将来会引用它附近的一个内存位置

 

## 3、如何评价程序的局部性？或者说如何利用程序的局部性编写缓存友好的代码？

重点还是理解时间局部性和空间局部性来回答。

- 重复引用相同变量的程序具有良好的局部性
- 对于具有步长为$k$的引用模式，步长越小，空间局部性越好
- 对于取指令来说，循环有好的时间和空间局部性，循环体越小（空间），迭代次数越多（时间），局部性越好。

## 4、缓存命中，缓存不命中，缓存不命中的种类？

高速缓存：一个小而快速的存储设备，作为存储在更大、也更慢的设备中的数据对象的缓冲区域。

缓存命中：当程序需要第$k+1$层的某个数据对象$d$时，如果$d$恰好在缓存在第$k$层时，则缓存命中。

缓存不命中：相反情况。涉及到的相关概念，替换、牺牲块、替换策略、随机替换策略、最近最少使用替换策略。概念需要理解，更能够理解缓存的过程。

缓存不命中的种类：

- 强制不命中：缓存为空，是一个短暂事件
- 冲突不命中：缓存足够大，能够保存被引用的数据对象，但是这些对象每次都被映射到同一个缓存块，缓存会一直不命中。（这部分需要理解放置策略）
- 容量不命中：工作集的大小大于缓存大小。

## 5、提出缓存的本质，或者说缓存为什么有效？

基于缓存的存储器层次结构之所以有效，是因为较慢的存储设备比较快的存储设备便宜，还因为程序倾向于展现出局部性：

- 利用时间局部性：一旦缓存命中之后，希望对该目标有一系列的访问命中。
- 利用空间局部性：不同层之间的存储器通过块作为传送单元，希望对块中其他对象的访问能够步长不命中后复制该块的花费。



## 6、高速缓存存储器的组成？

- 高速缓存包含$S$个高速缓存组
- 每个高速缓存组包含$E$个高速缓存行
- 每个高速缓存行包含：一个数据块$B$，一个有效位（表示改行的信息是否有意义），t个标记位（当前块的内存地址的一个子集）

高速缓存块大小$C=S\times E \times B$

## 7、高速缓存器是如何工作的？

个人感觉有点基数排序的思想，划分不同的bin，提高了效率。

以直接映射的高速缓存举例：就是高速缓存行$E=1$的高速缓存。

另外高速缓存用中间的位来做组索引，而不是高位，使得相邻的块总是映射到不同的高速缓存行，根据程序的局部性，提高高速缓存的使用效率。

- 组选择：将地址$w$中抽取出$s$个组索引位，解释成一个无符号整数，即确定了高速缓存的组索引。
- 行匹配：地址$w$的标记位是否和选择的高速缓存组的标记位匹配，匹配则缓存命中，否则缓存不命中。
- 字抽取：缓存命中，通过块偏移位访问字；缓存不命中时，从下一层存储器取出被请求的块，然后将新的存储块按照组索引存储在高速缓存行中。

## 8、高速缓存如何写？

- 1、写命中时：在高速缓存已经更新了$w$，要将$w$写入下一层存储器。

  - 直写：立即将$w$的高速缓存块写会到下一层存储器中。简单但是每次写都会引起总线流量。

  - 写回：尽可能推迟更新，只有当替换算法要驱逐这个更新过的块时，才写回。由于局部性，能够显著的较少总线流量。但是增加了复杂性，需要额外维护一个修改位，表明这个高速缓存块是否被修改过。（这大概就是文件的flush吧）

- 2、写不命中时：高速缓存中没有命中$w$
  - 写分配：加载第一层的存储器的块到高速缓存中，再更新这个高速缓存块
  - 非写分配：避开高速缓存，直接把这个字写入到低一层中。

直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的。



## 9、高速缓存的性能指标？

- 不命中率：`不命中数量/引用数量`
- 命中率：`1-不命中率`
- 命中时间：从高速缓存传送一个字到CPU所需要的时间，包括行选择、组匹配、字抽取的时间。
- 不命中处罚：由于不命中所需要的额外时间。

## 10、高速缓存的性能影响？

- 1、高速缓存大小的影响：
  - 较大的缓存可能提高命中率
  - 可能增加命中时间。这也解释了缓存为什么一级比一级大。大小：L1<L2<L3。
- 2、块大小的影响：
  - 较大的块能够利用可能存在的空间局部性，提高命中率。
  - 降低时间局部性，但是对于给定的高速缓存大小，意味着高速缓存行数减少。
  - 块大不同存储器之间的传送时间会变长。

- 3、相联度的影响：这部分我没有看
- 4、写策略的影响：
  - 直写容易实现，可以使用独立于高速缓存的写缓冲区来更新内存。
  - 读不命中开销相对小
  - 写回策略可以是传送次数减少，降低总线流量。
  - 高速缓存越往下层越可能用写回而不是直写。因为越往层次结构下面走，传送时间增加，减少传送次数就变的重要。



# 四、虚拟内存

